# 48-旋转图像

> 中等  
> 数组

### 题目描述

给定一个 *n* × *n* 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

#### 示例1:

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

#### 示例2：

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

</br>

### 题目分析

题目说到要在原数组上操作，所以会涉及到数组元素的调换。具体怎么转换呢，一次循环搞定，时间复杂度为`O(n²)`！

每次循环旋转一层的元素，由外向内，最终到没有剩余的元素（n为偶数）或剩余一个元素时结束（n为奇数），总共有`n/2`层。

设当前旋转的是第`i`层，第`j`个元素

我们来看下图（1），此时`i=0`，我们要旋转最外层元素，把元素分成4块（上下左右）来看，分别是`[5,1,9][11,10,7][14,12,16][2,13,15]`，每次我们旋转4个元素，所以总共要旋转3次`(n-1-i)`。

如图（2）先旋转的`5、11、16、15`

紧接着图（3）`1、10、12、13`

最后旋转到图（5）的情况，就完成了一层的旋转。然后`i++`，下一层同样要把元素分成4块（上下左右），但只需要分成`[4][8][6][3]`

本题目难点就在于坐标的设置和循环结束条件。第一层循环刚刚说了总共有n/2层（向下取整），第二层循环，分块后每块需要旋转几个元素，上侧元素是从`j=i`开始，到`n-1-i`结束（不包含），即`j`取值范围`[i,n-1-i)`。

那么就开始就交换位置了，先暂存【上】的元素，【左】赋值到【上】，【下】赋值到【左】，【右】赋值到【下】，再把刚刚暂存的赋值到【右】

![pic](https://github.com/hinkleung/leetcode/blob/main/problems/48-旋转图像/48-pic.jpg)

### 代码实现

```java
class Solution {
    public void rotate(int[][] matrix) {
        int temp;
        int n = matrix.length;
        for(int i=0;i<n/2;i++){
            //从外层到内层逐层旋转，只有n/2层需要旋转
            for(int j=i;j<n-1-i;j++){
                //每层中需要旋转的元素随着i的增大而减少
                temp = matrix[i][j];
                matrix[i][j]=matrix[n-1-j][i];			//【左】赋值到【上】
                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];	//【下】赋值到【左】
                matrix[n-1-i][n-1-j]=matrix[j][n-1-i];	//【右】赋值到【下】
                matrix[j][n-1-i]=temp;					//【上】赋值到【右】
            }    
        }
    }
}
```

### 执行结果

![pic](https://github.com/hinkleung/leetcode/blob/main/problems/48-旋转图像/48-result.png)
