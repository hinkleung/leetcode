# 136-只出现一次的数字

>简单  
>哈希表、异或

#### 题目描述

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例**

```
示例 1:
输入: [2,2,1]
输出: 1

示例 2:
输入: [4,1,2,1,2]
输出: 4
```



#### 题目分析一

先来讲讲用Map来解决，遍历数组，利用遍历到的数字作为Key，在Value上+1，最后判断谁是只value=1的。



#### 代码实现一

```java
class Solution {
    public int singleNumber(int[] nums) {
        //解法一：哈希表
        Map<Integer,Integer> map = new HashMap<>();
        for(int num:nums){
            Integer count = map.get(num);
            map.put(num,count==null?1:count+1);
        }

        for(Integer i : map.keySet()){
            if(map.get(i)==1){
                return i;
            }
        }
        return -1;
    }
}
```



#### 题目分析二

一看到题目，就想到了果然是个简单题，这不是用`Map`就能实现吗？于是噼里啪啦打下了以下代码，提交是通过了，但是运行时间和空间惨不忍睹，击败8%....

看了官方的解析，知道了这道题可以用异或，先来分析一下题目，有一个我一开始没有注意到的点，**除了某个元素只出现一次以外，其余每个元素均出现两次**。OK，再来了解一下异或，如果两个值不相同，则异或结果为1，如果两个值相同，异或结果为0。异或的数学符号为“⊕”。

异或满足归零律，即`a ⊕ a = 0`

异或满足交换律，即`a ⊕ b = b ⊕ a`

异或满足恒等律，即`a ⊕ 0 = a`

异或满足结合律，即`a ⊕b ⊕ c = a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c`

加上本题目，如果把输入中的所有元素作异或运算，如`[4,1,2,1,2]`，则有`4⊕1⊕2⊕1⊕2 = 4⊕1⊕1⊕2⊕2 = 4⊕0⊕0 = 4`，由于其他元素出现两次，那么异或最后的结果肯定就是只出现一次的元素。



#### 代码实现二

```java
class Solution {
    public int singleNumber(int[] nums) {
        //解法二；异或
        int ans = nums[0];
        for(int i=1;i<nums.length;i++){
            ans = ans ^ nums[i];
        }
        return ans;
    }
}
```

