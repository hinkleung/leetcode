# 31-下一个排列

>中等  
>数组

#### 题目描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。


**示例**

```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```



#### 题目分析

这道题一开始在纸上写了一下，能琢磨出要从排列的后面寻找调换的位置，其实这道题用不到什么算法，就是要总结规律，然后数组操作就行了。

先来看一下例子吧，[1,2,3,4,5,6]

1234**56**  ->  123**46**5  ->  1235**46**  ->  123**56**4  ->  1236**45**  ->  12**36**54  -> ...... ->   654321  -> 123456



对着上面例子我们来完成几个目标：

1、如何找到比当前大的数字？只要把后面**较大**的数换到前面就行了，比如`123456`，交换`5`、`6`位置，得到`123465`。即**[后大数]**换**[前小数]**。ok，第一个目标达成。

2、如何保证所找的数字是**下一个**更大的值，即此次交换是**增幅最少**。

&emsp;&emsp;i.首先尽可能调换**后面**的数字，因为前面的换位置，越往前×10就越多，增幅越大。

&emsp;&emsp;ii.**[后大数]**尽可能小，比如`123465`换的是`4`和`5`而不是`4`和`6`

&emsp;&emsp;iii.换完数之后，**[前小数]**的后面的所有数置为**升序**，因为升序的数最小。

3、如何找到**[后大数]**和**[前小数]**

&emsp;&emsp;i.**[前小数]**是从后面开始往前寻找的**第一个相邻的顺序数的左边数**，比如我在上面例子中加粗的部分的**左边数**

&emsp;&emsp;ii.**[前小数]**后面的数都是逆序的，从中找出**最小的且比前小数大的数**，作为**[后大数]**

4、当整个数都是逆序，说明到头了，反转整个数，获得最小数（顺序）。



*问：为什么要从后面找第一个相邻的顺序数？*

*答：如果不是顺序的话，反转得到的数更小，从后面开始是因为越往前×10就越多，增幅越大*



#### 代码实现

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int length = nums.length;
        int i=length-2,j=length-1,k=length-1;
        //寻找第一个相邻顺序对
        while(i>=0 && nums[i]>=nums[j]){
            i--;
            j--;
        }
        //不是全逆序（全逆序直接把参数翻转提交）
        if(i>=0){
            //寻找j后面的最小的【大数】
            while(nums[i]>=nums[k]){
                k--;
            }
            swap(nums,i,k);
        }
        //将后面的降序变为正序
        reverse(nums,j,length-1);
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i]=nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums, int i, int j){
        while(i<j){
            swap(nums,i,j);
            i++;
            j--;
        }
    }
}
```

#### 提交结果

![31提交结果图](https://github.com/hinkleung/leetcode/blob/main/solution/31-下一个排列/31-result.png)
